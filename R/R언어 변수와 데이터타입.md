# R언어 변수와 데이터타입

참조문서 : [R을 이용한 데이터 처리 & 분석 실무](https://thebook.io/006723/)

## 1. 변수
변수의 타입은 명시적으로 지정을 안해줘도 사용이 가능하다. 

### 1-1. 명명규칙
명명규칙으로 변수명은 알파벳, 숫자, _(언더스코어), .(마침표)로 구성되며, -(하이픈)은 사용할 수 없다. 첫 글자는 알파벳 또는 .(마침표)으로 시작해야 한다. 만약 .(마침표)으로 시작한다면 .(마침표)뒤에는 숫자가 올 수 없다. 

R 1.9.0 이전에는 변수명에 \_를 사용할 수 없었다. 이런 이슈로 다른 언어에서 흔히 \_를 사용할 만한 상황에서 R은 .(마침표)을 사용한다. 예를 들어, training\_data, validation\_data 같은 변수명 대신 data.training, data.validation과 같이 마치 객체의 속성을 접근하는 것처럼 보이는 명명 방식이 종종 사용된다.

### 1-2. 할당
할당연산자로 <- , <<- , = 를 사용할 수 있다. <- 와 <<- 는 스코프차이가 있으며, <- 와 = 는 = 는 명령의 최상위 수준에서만 사용할 수 있는 반면, <- 는 어느 곳에서나 사용할 수 있다. 따라서 함수 호출과 동시에 변수에 값을 할당하는 목적으로는 <- 만 사용할 수 있다.

	> mean(x = c(1, 2, 3))
	[1] 2
	> x
	Error: object 'x' not found

만약 위에서 = 대신 <- 를 사용하면 정상 작동한다.

## 2. 데이터타입
R에서는 기본형이 벡터이다. R의 자료형은 아래처럼 6가지로 나눌 수 있다.

* 요인
* 벡터
* 리스트
* 행렬
* 배열
* 데이터 프레임

이중에서 백터의 길이가 1인 것을 스칼라라고 부른다. `class(객체)` 를 호출하여 문자열로 데이터타입을 반환받을 수 있다.

### 2-1. 스칼라(Scalar)
스칼라란 단일 차원의 값을 뜻하며, 길이가 1인 벡터와 같은 동일하다. 즉, 구성인자가 하나인 벡터를 말한다. 스칼라는 정수, 부동소수, 문자열(홀따옴표나 쌍따옴표로 묶어야한다), 논리값(TRUE, T, FALSE, F), NA, NULL 의 데이터타입을 갖는다. 이를 **스칼라 데이터타입**이라고 부른다.

#### 2-1-1. NA(Not Available)
NA는 데이터 값이 없음을 뜻한다. NA는 결측치, 즉 값이 빠져 있는 경우를 뜻한다. `is.na(변수명)` 을 통해 참거짓을 확인할 수 있다.

#### 2-1-2. NULL
NULL은 NULL 객체를 뜻하며, 변수가 초기화되지 않았을 때 사용한다. NULL은 프로그래밍의 편의를 위해 미정(undefined) 값을 표현하는 데 사용하는 개념이다. `is.null(변수명)` 을 통해 참거짓을 확인할 수 있다.

### 2-2. 요인(Factor)
요인은 범주형 데이터를 표현한다. 범주형 데이터란 데이터가 사전에 정해진 특정 유형으로만 분류되는 경우를 뜻한다.

	> sex <- factor("m", c("m", "f"))
	> sex
	[1] m
	Levels: m f
	> levels(sex) <- c("male", "female")
	> sex
	[1] male
	Levels: male female

sex 변수를 출력해보면 값은 m이고 이 변수가 가질수 있는 수준은 m, f 중에 하나이다. 요인들이 가질 수 있는 값들을 수준(Level)이라고 한다. 만약 이 범주안에 없는 값(첫번째 인자)을 넣어주면 NA라고 뜬다. 요인은 명목형과 순서형으로 구분되는데, 명목형은 값들 간에 순서비교가 불가능하고, 순서형은 가능(ordered=TRUE)하다. 기본적으로 명목형이다.

* factor(값, levels, ordered=T 또는 F) 로 호출하면 요인을 반환한다. levels 인자를 생략하면 값으로부터 자동으로 레벨의 목록을 파악한다.
* nlevels(요인변수) : 범주의 수를 반환한다.
* levels(요인변수) : 범주목록을 반환한다.
* is.factor(객체) : 참거짓 확인
* ordered(값, levels) 로 호출하면 순서형 요인을 반환한다. 즉 actor(값, levels, ordered=T)와 같다.
* is.ordered(객체) : 참거짓 확인

### 2-3. 벡터(Vector)
#### 2-3-1. 벡터의 정의
하나의 원소여도 벡터로 취급한다. 벡터는 다른 언어의 배열과 비슷하며, 한 가지의 스칼라 데이터타입의 데이터들을 저장할 수 있다. 만약 서로 다른 스칼라 데이터타입이 섞여있다면 자동 형변환을 한다. 이때 변환규칙은  NULL < raw < logical < integer < double < complex < character < list < expression 순서이다.

벡터는 중첩할 수 없다. 따라서 벡터 안에 벡터를 생성하면 단일 차원의 벡터로 변경된다.

	> c(1, 2, 3, c(1, 2, 3))
	[1] 1 2 3 1 2 3

벡터의 각 요소에는 이름을 부여할 수 있다. 따라서 벡터에 저장된 요소들을 인덱스를 사용하여 접근하는 것뿐 아니라 이름을 사용해서도 접근할 수 있다. 참고로 R언어의 **모든 인덱스는 0이 아닌 1부터 시작한다.**

* c(값1, 값2, ...) 로 호출하면 벡터를 반환한다. c는 concatenate로서 여러 벡터들을 붙여주는 함수이다. 즉, 각각의 스칼라들을 붙여 하나의 벡터를 만드는 것이다.
* names(벡터) : 벡터 요소들의 이름을 반환한다.
* length(벡터) : 벡터 길이를 반환
* NROW(벡터) : 벡터를 n행 1열의 행렬로 취급해 길이를 반환한다. 행의 수를 반환하는데 length()와 같다.
* is.numeric(객체) : 숫자를 저장하는 벡터인지 참거짓 확인
* is.character(객체) : 문자열을 저장한 벡터인지 참거짓 확인

#### 2-3-2. 벡터 데이터의 접근
* x[n] : 벡터 x의 n번째 요소. n은 숫자 또는 요소명.
* x[-n] : 벡터 x에서 n번째 요소를 제외한 나머지. n은 숫자 또는 요소명.
* x[색인벡터] : 벡터 x로부터 색인벡터에 지정된 요소를 얻어옴. 이때 색인벡터는 숫자 벡터 또는 요소명을 표현하는 문자열 벡터.

		> x <- c("a", "b", "c")
		> x[c(1, 3)]
		[1] "a" "c"
* x[start:end] : 벡터 x의 start부터 end까지의 값을 반환함. 반환 값은 start 위치의 값과 end 위치의 값을 모두 포함함.

		> x[2:3]
		[1] "b" "c"

#### 2-3-3. 벡터 집합연산
* identical(x, y) : 벡터 x와 y가 같은 벡터이면 TRUE, 다르면 FALSE

		> identical(c(1, 2, 3), c(1, 2, 3))
		[1] TRUE
		> identical(c(1, 2, 3), c(1, 2, 100))
		[1] FALSE
* union(x, y) : 벡터 x와 y의 합집합
* intersect(x, y) : 벡터 x와 y의 교집합
* setdiff(x, y) : 벡터 x와 y의 차집합
* setequal(x, y) : 벡터 x와 y가 같은 집합이면 TRUE, 다르면 FALSE

		> setequal (c("a", "b", "c"), c("a", "d"))
		[1] FALSE
		> setequal (c("a", "b", "c"), c("a", "b", "c", "c"))
		[1] TRUE

#### 2-3-4. 벡터 연산
* value %in% x : 벡터 x에 value가 저장되어 있으면 TRUE, 없으면 FALSE

		> "a" %in% c("a", "b", "c")
		[1] TRUE
* x + n : 벡터 x의 모든 요소에 n을 더한 벡터를 구함. 마찬가지로 *, /, -, == 등의 연산자를 적용 가능함

		> x <- c(1, 2, 3, 4, 5)
		> x + 1
		[1] 2 3 4 5 6
		> 10 - x
		[1] 9 8 7 6 5
		> c(1, 2, 3) == c(1, 2, 100)
		[1] TRUE TRUE FALSE
		> c(1, 2, 3) != c(1, 2, 100)
		[1] FALSE FALSE TRUE

#### 2-3-5. 연속되거나 반복되는 벡터
* seq(시작값, 끝값, 증가치) : 증가치는 생략가능하며 시퀀스를 생성한다. seq()를 쓰지않고 시작값:끝값만 써도 동일하다.
* rep(반복할 값이 저장된 벡터, 전체 반복횟수, each=개별 반복횟수) : 주어진 값을 반복하는 벡터를 생성한다.

		> rep(1:2, times=5)
		[1] 1 2 1 2 1 2 1 2 1 2
		> rep(1:2, each=5)
		[1] 1 1 1 1 1 2 2 2 2 2
		> rep(1:2, each=5, times=2)
		[1] 1 1 1 1 1 2 2 2 2 2 1 1 1 1 1 2 2 2 2 2

### 2-4. 리스트(List)
#### 2-4-1. 리스트의 정의
리스트는 다른 언어의 hash table이나 dictionary에 해당되며 키값 형태의 연관 배열이다. 벡터와 다른 점은 서로 다른 스칼라 데이터타입을 저장할 수 있다. 각 값은 꼭 스칼라일 필요가 없으며 벡터를 저장할 수도 있다. 예를들면 "닉네임" 이라는 키에 "빨간색코딩" 이라는 값을 저장하고, "나이" 이라는 키에 25라는 숫자 값을 저장할 수 있다. 또한 벡터와 달리 중첩도 가능하다.

* list(키=값, 키=값, ...) 을 호출해서 list를 만들 수 있다.

		> x <- list (a=list(val=c(1, 2, 3)), b=list(val=c(1, 2, 3, 4)))
		> x
		$a
		$a$val
		[1] 1 2 3
		
		
		$b
		$b$val
		[1] 1 2 3 4

#### 2-4-2. 리스트의 데이터 접근
리스트에 저장된 데이터는 인덱스 또는 키를 사용해 접근할 수 있다.

* x$key : 리스트 x에서 키 값 key에 해당하는 값
* x[[n]] : 리스트 x에서 n번째에 저장된 값
* x[n] : 리스트 x에서 n번째 데이터의 서브리스트

### 2-5. 행렬(Matrix)
#### 2-5-1. 행렬의 정의
벡터는 동일한 스칼라 데이터타입의 1차원 데이터 구조인 반면, 행렬은 동일한 스칼라 데이터타입의 2차원 데이터 구조를 말한다. 

* matrix(벡터 값, nrow=행의 수, ncol=열의 수, byrow=T면 행우선 F면 열우선으로 데이터를 채움, dimnames=행렬의 각 차원의 이름저장)
* dimnames(행렬) : 행렬의 각 차원명

		> dimnames(x) <- list(c("r1", "r2", "r3"), c("c1", "c2", "c3"))
		> x
		   c1 c2 c3
		r1  1  4  7
		r2  2  5  8
		r3  3  6  9
* rownames(행렬) : 행렬의 행 이름
* colnames(행렬) : 행렬의 열 이름
* nrow(행렬) : 행렬의 행의 수
* ncol(행렬) : 행렬의 열의 수
* is.matrix(객체) : 참거짓 확인

#### 2-5-2. 행렬의 데이터 접근
행렬은 색인 또는 행과 열의 이름을 통해 접근할 수 있다. `-색인` 형태로 음수를 사용해 특정 행이나 열을 제외하거나, 색인에 벡터를 지정해 여러 값을 한 번에 가져올 수 있다.

* 행렬변수[행 인덱스, 열 인덱스]

		> x[1:2, ]
		    [,1] [,2] [,3]
		[1,]   1    4    7
		[2,]   2    5    8

#### 2-5-3. 행렬연산
* A + x : 행렬 A의 모든 값에 스칼라 x를 더한다. 이외에도 -, *, / 연산자를 사용할 수 있다.
* A + B : 행렬합을 구한다. 행렬차는 - 연산자를 사용한다.
* A %*% B : 행렬곱을 구한다.
* t(행렬이나 데이터프레임) : 전치행렬(모든 열을 대응하는 행으로 바꿈)을 구한다.
* solve(행렬1, 행렬2) : 행렬1 %*% x = 행렬2에서 x를 구한다. 행렬2를 지정하지 않으면 행렬1의 역행렬을 구한다.

### 2-6. 배열(Array)
#### 2-6-1. 배열의 정의
행렬이 2차원 데이터라면 배열은 N차원 데이터다. 역시 하나의 스칼라 데이터타입만을 가진다. 예를 들어, 2×3 차원의 데이터를 행렬로 표현한다면 2×3×4 차원의 데이터는 배열로 표현한다.

* array(데이터 벡터, dim=배열의 차원, dimnames=차원명) 로 호출하면 배열이 반환된다.

		> x <- array(1:12, dim=c(2, 2, 3))
		> x
		, , 1
		     [,1] [,2]
		[1,]    1   3
		[2,]    2   4
		
		, , 2
		     [,1] [,2]
		[1,]    5   7
		[2,]    6   8
		
		, , 3
		     [,1] [,2]
		[1,]    9   11
		[2,]   10   12
* is.array(객체) : 참거짓 확인

#### 2-6-2. 배열의 데이터 접근
* dim(배열) : 배열의 차원의 수
* 배열변수[행 인덳, 열 인덱스, 차원 인덱스] 로 접근한다.

		> x[1,2,1]
		[1] 3

### 2-7. 데이터프레임(Data Frame)
#### 2-7-1. 데이터프레임의 정의
데이터 프레임은 스칼라 데이터타입에 상관없이 2차원 형태의 데이터 구조를 말한다. 또한 다양한 변수, 관측치, 범주 등을 표현하기 위해 특화되었다. R언어에서 가장 많이 쓰인다. `변수$열이름 <-` 을 통해 새로운 데이터도 저장할 수 있다. data.frame를 생성할 때 인자에 넣는 문자열벡터는 요인으로 변환되지만, 이후에 `변수$열이름 <-` 을 통해 저장한 문자열 벡터는 그대로 문자열벡터이다.

* data.frame(키=값, 키=값, ... , stringsAsFactors=문자열을 요인으로 저장하면 T 문자열로 저장하려면 F) 로 호출하면 데이터 프레임이 생성된다.
* is.data.frame(객체) : 참거짓 확인

#### 2-7-2. 데이터프레임의 데이터 접근
데이터프레임에 저장된 데이터는 인덱스 또는 키를 사용해 접근할 수 있다.

* d$colname : 데이터 프레임 d의 컬럼 이름 colname에 저장된 데이터.
* d[m, n, drop=T] : 데이터 프레임 d의 m행 n 컬럼에 저장된 데이터. 특정 칼럼을 가져올 때 형변환을 원치 않으면 drop=F를 하면 데이터프레임을 반환한다.

## 3. 타입변환
데이터타입을 명시적으로 바꿔줄 수 있다.

* as.factor(객체): 요인으로 변환
* as.numeric(객체) : 숫자를 저장한 벡터로 변환
* as.character(객체) : 문자열을 저장한 벡터로 변환
* as.matrix(객체) : 행렬로 변환
* as.array(객체) : 배열로 변환
* as.data.frame(객체) : 데이터프레임으로 변환